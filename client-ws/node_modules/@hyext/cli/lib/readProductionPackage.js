let path = require('path')
let fse = require('fs-extra')
let readPkgTree = require('read-package-tree')
const chalk = require('chalk')

module.exports = function (root, filter = () => {}, deepResolve = () => {}) {
  let basedir = root || process.cwd()

  return readPkgTree(basedir).then( pkgTree => getProdPkgList(basedir, getPkgList(pkgTree), filter, deepResolve) )
}

function getPkgList (pkgTree) {
  let list = []

  pkgTree.children.forEach(add)

  function add (pkg) {
    list.push(pkg)
    pkg.children.forEach(add)
  }

  return list
}

function getProdPkgList (root, pkgList, filter, deepResolve) {
  let list = []

  Object.keys( fse.readJsonSync( path.join(root, 'package.json') ).dependencies || {} )
    .forEach(id => add( getPkg(id, root, pkgList, null) ) )

  function add (pkg) {
    if (pkg && list.indexOf(pkg) == -1 && filter(pkg) !== false) {
      list.push(pkg)

      if (deepResolve(pkg) !== false) {
        Object.keys(pkg.package.dependencies || {})
          .forEach(id => add( getPkg(id, pkg.path, pkgList, pkg) ) )
      }
    }
  }

  let topLevelPkg = []

  list.sort((a, b) => a.path.length < b.path.length ? -1 : 1)    // 路径短的放前面
    .forEach(item => {
      let included = topLevelPkg.some(pkg => path.relative(pkg.path, item.path).slice(0, 2) != '..')

      if ( !included ) {
        topLevelPkg.push(item)
      }
    })

  return topLevelPkg
}

function getPkg (id, from, pkgList, parent) {
  let resolvePkg = null
  let resolvePath = resolve(id, from, parent)

  pkgList.some(pkg => {
    let files = pkg.package.main ? 
      [
        pkg.package.main, 
        `${pkg.package.main}.js`, 
        `${pkg.package.main}.json`,
        `${pkg.package.main}/index.js`, 
        `${pkg.package.main}/index.json`
      ] : 
      ['index.js', 'index.json']

    /* 
     * “pkg.realpath == resolvePath” 用于：
     * 1. 当 pkg 是一个目录，但无法resolve的情况 (没有 package.json或package.json没有main字段或main字段无效 的同时 不存在index.js或index.json文件)
     * 2. 当 pkg 是一个js文件的情况
     */
    let resolved = files.some(file => path.join(pkg.realpath, file) == resolvePath) || pkg.realpath == resolvePath

    if ( resolved ) {
      resolvePkg = pkg 
      return true
    }
  })

  if ( !resolvePkg ) {
    throw new Error(`The module '${id}' does not exist in your project. (The resolved filename: '${resolvePath}', the node_modules hierarchy is checked from '${path.join(from, 'node_modules')}')`)
  }

  return resolvePkg
}

function resolve (id, from, parent) {
  let resolvePath = ''

  try {
    resolvePath = require.resolve(id, {paths: [path.join(from, 'node_modules')]})
  } catch (e) {}

  /*
   * 1. 处理因以下原因导致 require.resolve 失败的情况 
   * 存在 node_modules/<id> 目录 但里面的 package.json 没有 main 字段
   * 并且目录根部没有 index.js 或 index.json 文件
   *
   * 2. 当 id 是node核心模块的情况
   */
  if (!resolvePath || require.resolve.paths(id) === null) {
    // 如果 id 是node核心模块 那 resolvePath 的值会等于 id
    // 这对于我们来说是无效的值，所以要重置它
    resolvePath = ''

    if ( fse.existsSync( path.join(from, 'node_modules', id) ) ) {
      resolvePath = path.join(from, 'node_modules', id) 
    } else if (parent) {
      resolvePath = find(parent)

      function find (parent) {
        let pathDir = path.join(parent.realpath, 'node_modules', id)

        return fse.existsSync(pathDir) ? pathDir : (parent.parent ? find(parent.parent) : '')
      }
    }
  }

  if ( !resolvePath ) {
    throw new Error(`Can't find module '${id}'. (The node_modules hierarchy is checked from '${path.join(from, 'node_modules')}')`)
  }

  return resolvePath
}
