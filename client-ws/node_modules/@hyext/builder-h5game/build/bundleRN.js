const { spawn } = require('child_process')
const os = require('os')
const fs = require('fs-extra')
const path = require('path')
const R = require('ramda')
const { createLauncher, deleteLauncher } = require('@hyext/game-launcher')

const md5 = require('./md5.js')
const { generateMetroConfig, removeMetroConfig } = require('./generateMetroConfig.js')
const { HINT, ERROR } = require('../utils/utils.js')
const constants = require('../constants.js')
const { copyConfigAssets } = require('../lib/copyConfigAssets.js')

/*
 * 客户端的实现依赖具体的 bundleName
 * 观众端: app_streamer.[ios/android].jsbundle
 * 主播端: app.[ios/android].jsbundle
 */
function getBundleName({ extType, platform }) {
  const [appType] = extType.split('_')

  const appNameMap = {
    app: 'app',
    zs: 'app_streamer',
  }

  return `${appNameMap[appType]}.${platform}.jsbundle`
}

function bundleEntry({ projectDir, platform, inputAbsPath, outputAbsPath, outputDir, metroConfigAbsPath }) {
  return new Promise((resolve, reject) => {
    const bundleProcess = spawn(
      'node',
      [
        `${projectDir}/node_modules/react-native/local-cli/cli.js`,
        'bundle',
        '--platform',
        platform,
        '--dev',
        false, // FIXME 如果打开 dev 模式, 那么图片资源 uri 的替换将会失效
        // process.env.NODE_PACK_DEBUG === 'true',
        '--entry-file',
        inputAbsPath,
        '--bundle-output',
        outputAbsPath,
        '--config',
        metroConfigAbsPath,
        '--assets-dest',
        outputDir,
      ],
      {
        // 忽略输入, 把 stdout 输出到父进程的 stdout, 自己处理 stderr
        stdio: ['ignore', 'inherit', 'pipe'],
        cwd: projectDir,
      },
    )

    let errOut = []
    bundleProcess.stderr.on('data', data => {
      errOut = errOut.concat(data.toString().split('\n'))
    })


    bundleProcess.on('close', async code => {
      if (code === 0) {
        const md5OfFile = await md5(outputAbsPath)
        resolve(md5OfFile)
        return
      }

      reject(errOut.join('\n'))
    })

    bundleProcess.on('error', (err) => {
      reject(`打包失败, ${err}`)
    })
  })
}

async function bundleRN({ projectDir, launcherDir, hygFileList, extUuid, extVersion, buildConfig, outputDir, publicPath, engineType, config }) {
  const processedAppTypeEntry = {}
  let bundleTaskNo = 0
  let bundleInfo = {}

  // 确保不要放在包含在 node_modules 的路径中, 否则拆包的时候 module_id 会不一致
  // const launcherDir = path.resolve(launcherParentDir, `launcher-${extUuid}-${extVersion}`)
  HINT(`\nHYEXT-H5Game: 生成 RN 项目: ${launcherDir}\n`)

  let launcherFactory = createLauncher
  if (config.customLauncher) {
    HINT(`使用自定义 launcher: ${config.customLauncher}`)
    try {
      const launcher = require(path.resolve(projectDir, config.customLauncher))
      launcherFactory = launcher.createLauncher
    } catch (err) {
      ERROR('未找到自定义 launcher')
      console.error(err)
      throw err
    }
  }

  const { entries, SDK } = await launcherFactory({
    extVersionType: 3,
    engineType,
    hygFileList,
    // FIXME hardcode
    hygFileType: 2,
    outputDir: launcherDir,
  })

  // 拷贝文件到 launcherDir
  copyConfigAssets({ projectDir, launcherDir, config })

  for (const buildCfg of buildConfig) {
    const { extType } = buildCfg

    const { entry, registerComponent } = entries[extType] || entries.default
    const isBuildingStremerBundle = extType.startsWith('zs_')
    const appType = isBuildingStremerBundle ? 'streamer' : 'kiwi'

    for (const platform of ['ios', 'android']) {
      const appTypeEntryKey = `${entry}_${appType}_${platform}`

      if (processedAppTypeEntry[appTypeEntryKey]) {
        HINT(`\nHYEXT: 相同类型的入口文件${appTypeEntryKey}已经处理过, 无需再次构建`)
        const target = processedAppTypeEntry[appTypeEntryKey]

        bundleInfo = R.mergeDeepLeft(
          {
            [extType]: {
              [platform]: {
                bundleName: target.bundleName,
                md5: target.md5OfFile,
                bundleDir: target.bundleDir,
                registerComponent,
                SDKVersion: SDK[appType],
              },
            },
          },
          bundleInfo,
        )

        continue
      }



      bundleTaskNo += 1

      HINT(`\nHYEXT: 打包任务[${bundleTaskNo}]: 入口文件${entry}, 终端${extType}, 平台${platform}`)

      const extTypeOutputDir = path.resolve(outputDir, extType)
      await fs.ensureDir(extTypeOutputDir)

      const bundleName = getBundleName({ extType, platform })
      const outputAbsPath = path.resolve(extTypeOutputDir, bundleName)

      const seperator = publicPath.endsWith('/') ? '' : '/'
      const publicPathWithExtType = `${publicPath}${seperator}${path.basename(extTypeOutputDir)}`

      const metroConfigAbsPath = generateMetroConfig({
        extUuid,
        projectDir: launcherDir,
        isBuildingStremerBundle,
        publicPath: publicPathWithExtType,
        isUseHyCssLoader: false,
      })

      const md5OfFile = await bundleEntry({
        projectDir: launcherDir, // 传递给 spawn 的 cwd
        platform,
        inputAbsPath: path.resolve(launcherDir, entry),
        outputAbsPath,
        outputDir: extTypeOutputDir,
        metroConfigAbsPath,
      })

      processedAppTypeEntry[appTypeEntryKey] = {
        md5OfFile,
        bundleName,
        bundleDir: path.basename(extTypeOutputDir),
      }

      removeMetroConfig(metroConfigAbsPath)

      bundleInfo = R.mergeDeepLeft(
        {
          [extType]: {
            [platform]: {
              bundleName,
              md5: md5OfFile,
              bundleDir: path.basename(extTypeOutputDir),
              registerComponent,
              SDKVersion: SDK[appType],
            },
          },
        },
        bundleInfo,
      )
    }

  }

  if (process.env.NODE_PACK_DEBUG === 'true') {
    console.log(`HYEXT-H5Game: debug 模式, 跳过清理 launcher 文件夹 ${launcherDir}`)
  } else {
    deleteLauncher(launcherDir)
  }
  return bundleInfo
}

module.exports = {
  bundleRN,
}
