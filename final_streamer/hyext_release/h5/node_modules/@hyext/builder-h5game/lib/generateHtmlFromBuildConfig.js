const fs = require('fs-extra')
const path = require('path')
const cheerio = require('cheerio')
const crypto = require('crypto')

const { getPublicIP, ERROR, HINT } = require('../utils/utils.js')

const PREPROCESS_FILE_NAME = 'hyext-preprocess.js'

function injectTaf({ content }) {
  const $ = cheerio.load(content)
  $('body').prepend(`<script src='https://a.msstatic.com/huya/hd/cdn_libs/wsChannel2.min.js'></script>`)
  return $.html()
}

function injectSDK({ content, platform, webSDKVersion }) {
  // HINT(`\n SDK 类型: ${platform}, 版本: ${webSDKVersion}`)
  const $ = cheerio.load(content)
  $('body').prepend(`<script src='https://hyext.msstatic.com/hy-ext/${webSDKVersion}/hy-ext-${platform}.js'></script>`)
  return $.html()
}

function injectMeta({ content, extType, platform, extUuid, extName, extVersion, extVersionId, extSentryDsn }) {
  /*
   * 为什么把信息放在 meta 里而是不是 process.env.BAR?
   * 因为通常打包都是游戏引擎做的, builder-h5game 能做的东西太少了
   *
  */
  const $ = cheerio.load(content)
  $('head').append(`<meta name="ext-design-width" content="">`)
  $('head').append(`<meta name="ext-type" content="${extType}">`)
  $('head').append(`<meta name="ext-platform" content="${platform}">`)
  $('head').append(`<meta name="ext-uuid" content="${extUuid}">`)
  $('head').append(`<meta name="ext-name" content="${extName}">`)
  $('head').append(`<meta name="ext-version" content="${extVersion}">`)
  $('head').append(`<meta name="ext-version-id" content="${extVersionId}">`)
  $('head').append(`<meta name="ext-sentry-dsn" content="${extSentryDsn}">`)

  return $.html()
}

function injectPreProcess({ content }) {
  const $ = cheerio.load(content)
  $('body').prepend(`<script src='./${PREPROCESS_FILE_NAME}'></script>`)

  return $.html()
}

function injectSentry({ content }) {
  const $ = cheerio.load(content)
  $('body').prepend(`<script src='https://static-jw.msstatic.com/huya-sentry/ext-bundle.min.js'></script>`)

  return $.html()
}

function replaceTitle({ content, title }) {
  const $ = cheerio.load(content)
  $('head title').text(title)

  return $.html()
}

function extractInlineScript({ content, entryPath }) {
  const $ = cheerio.load(content)
  $('script').each((idx, el) => {
    if (!$(el).attr('src')) {
      const scriptContent = $(el).html()
      const contentMd5 = crypto
        .createHash('md5')
        .update(scriptContent)
        .digest('hex')
        .slice(0, 6)

      const filename = `hyext-extract-${idx}-${contentMd5}.js`
      const destPath = path.resolve(path.dirname(entryPath), filename)

      fs.writeFileSync(destPath, scriptContent)
      $(el).replaceWith(`<script src='./${filename}'></script>`)
    }
  })

  return $.html()
}

/*
 * 生成不同的入口 html 文件
 */
function generateHtmlFromBuildConfig({ extUuid = '', extName = '', extVersion = '', extVersionId = '', entryPath, outputDir, config }) {
  const content = fs.readFileSync(entryPath, { encoding: 'utf8' }).toString()

  fs.copyFileSync(path.resolve(__dirname, PREPROCESS_FILE_NAME), path.resolve(outputDir, PREPROCESS_FILE_NAME))

  const { useTaf, webSDKVersion = 'latest', buildConfig, webTitle = '虎牙小游戏' } = config

  // HINT(`\nHYEXT: 注入 title: ${webTitle}`)
  const contentWithTitle = replaceTitle({ content, title: webTitle })

  const entryHtmlDict = {}

  buildConfig.forEach(({ extType, platform }) => {
    // 小心覆盖项目的原有文件
    const filename = `${extUuid}-hyext-${extType}.html`
    entryHtmlDict[extType] = filename

    const dest = path.resolve(outputDir, filename)
    let newContent = contentWithTitle

    // script 标签用的是 prepend插入, 所以需要最先执行的请放后面
    // HINT(`\nHYEXT: 在文件 ${filename} 注入 sdk`)
    newContent = injectMeta({ content: newContent, platform, extType, extUuid, extName, extVersion, extVersionId, extSentryDsn: process.env.SENTRY_GAME_DSN })

    newContent = injectPreProcess({ content: newContent })

    newContent = injectSentry({ content: newContent })

    // sdk 需要先于 preProcess 注入, 因为 preProcess 依赖 sdk 的方法的判断环境
    newContent = injectSDK({ content: newContent, platform, webSDKVersion })

    if (useTaf) {
      // HINT(`\nHYEXT: 注入 Taf`)
      newContent = injectTaf({ newContent })
    }

    newContent = extractInlineScript({ content: newContent, entryPath })

    fs.writeFileSync(dest, newContent)
  })

  // console.log(entryHtmlDict)
  return entryHtmlDict
}

module.exports = {
  generateHtmlFromBuildConfig,
}
