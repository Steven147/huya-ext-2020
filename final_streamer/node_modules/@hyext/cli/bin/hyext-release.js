#!/usr/bin/env node

const commander = require('commander')
const path = require('path')
const fs = require('fs-extra')
const archiver = require('archiver')
const glob = require('glob')
const minimatch = require('minimatch')
const chalk = require('chalk')
const spawn = require('cross-spawn')
const packageJson = require('../package.json')
const readProductionPackage = require('../lib/readProductionPackage')
const readProjectConfig = require('../lib/readProjectConfig')

function main() {
  const program = new commander.Command(packageJson.name)
    .usage('release')
    .option('--no-compress', `don't make zip file`)
    // 主要用途: 同一个项目源码, 可以使用不同的 config 文件来发布到不同的小程序上
    .option('-c --config <config>', `指定配置文件`)
    .parse(process.argv);

  const { name: projectName, releasePath, builder: builderConfig, ignore: ignorePatterns } = readProjectConfig()

  const ROOT = process.cwd()

  const builder = require(path.resolve(ROOT, 'node_modules', builderConfig.name))

  if (typeof builder.verifyApp === 'function') {
    builder.verifyApp({ contextPath: ROOT })
      .catch(err => {
        console.error(`Release check failed: ${err}`)
        process.exit(1)
      })
  }

  if (typeof builder.release === 'function') {
    return builder.release({
      contextPath: ROOT,
      projectName,
      builderConfig,
      releasePath,
      ignorePatterns,
      compress: program.compress,
      cmdConfig: program.config,
    })
  }


  const releaseDir = path.resolve(releasePath, projectName)
  const releaseZip = path.resolve(releasePath, `${projectName}.zip`)

  fs.removeSync(releaseZip)
  fs.removeSync(releaseDir)
  fs.ensureDirSync(releaseDir)

  console.log(
    chalk.cyan(`pack ... (ignore: ${ignorePatterns.map(p => chalk.green(p)).join(', ')})`)
  );

  /*
   * node_modules 需要特殊处理
   * node_modules 只打包 dependencies 的
   *
   * Note:
   * 1. glob: '**', It does not crawl symlinked directories.
   * 2. glob 在 6.0版本后不再支持 否定模式 (the pattern starts with a '!' character)，而 minimatch 支持.
   * 3. glob 中，没法对传递给 options.ignore 的pattern进行配置(不能配置matchBase是硬伤)
   * 4. Please only use forward-slashes in glob expressions.
   */

  const fileMatch = (file, patterns, and) => {
    return ([]).concat(patterns)[and ? 'every' : 'some'](ptn => minimatch(file, ptn, { matchBase: true, dot: true }))
  }

  const readNodeModuleFiles = new Promise((resolve, reject) => {
    const pkgJsonPath = path.resolve(process.cwd(), 'package.json')
    const pkgJson = fs.existsSync(pkgJsonPath) ? fs.readJsonSync(pkgJsonPath) : null
    const dependencies = (pkgJson && pkgJson.dependencies) ? Object.keys(pkgJson.dependencies) : []

    if (dependencies.length > 0) {
      let root = process.cwd()

      readProductionPackage(
        root, 

        /* 
         * 以防开发者在手动安装 hyext 或 builder 时遗漏 --save-dev
         */
        pkg => (pkg.name != packageJson.name && pkg.name != builderConfig.name),

        /*
         * 如果模块的 package.json 被 ignore 命中
         * 则没必要再分析其依赖
         */
        pkg => {
          const relativePath = path.relative(root, pkg.path)
          const posixPath = path.posix.join.apply(path.posix, relativePath.split(path.sep))
          const m = fileMatch(`${posixPath}/package.json`, ignorePatterns)

          return m ? false : true
        }).then(packages => {
          let fileList = []

          packages.forEach(pkg => {
            let node_modules = path.resolve(root, 'node_modules')
            const relativePath = path.relative(node_modules, pkg.path)

            if (!path.isAbsolute(relativePath) && relativePath.slice(0, 2) != '..') {
              const posixPath = path.posix.join.apply(path.posix, relativePath.split(path.sep))
              const isDir = fs.statSync(pkg.realpath).isDirectory()

              if (isDir) {
                const pkgFiles = glob.sync(`node_modules/${posixPath}/**`, { dot: true, nodir: true })
                fileList = fileList.concat(pkgFiles)
              } else {
                fileList.push(`node_modules/${posixPath}`)
              }
            }
          })

          resolve(fileList)
        }).catch(reject)
    } else {
      resolve([])
    }
  })

  readNodeModuleFiles.then(nodeModuleFiles => {
    let fileList = glob.sync('**', { dot: true, nodir: true, ignore: 'node_modules/**' }).concat(nodeModuleFiles)

    ignorePatterns.forEach(pattern => {
      fileList = fileList.filter(minimatch.filter(`!${pattern}`, { matchBase: true, dot: true }))
    })

    fileList.forEach(file => {
      console.log(
        chalk.cyan(`  ${chalk.green(file)}`)
      );


      if (file === 'project.config.json' && program.config) {
        console.log(
          chalk.red(`\n  使用配置文件 ${program.config} 替换 zip 包的 project.config.json\n`)
        )
        fs.copySync(program.config, path.join(releaseDir, file))
      } else {
        fs.copySync(file, path.join(releaseDir, file))
      }
    })

    let compress = null

    if (program.compress !== false) {
      console.log(
        chalk.cyan(`compress ... `)
      );

      compress = new Promise((resolve, reject) => {
        const output = fs.createWriteStream(releaseZip)
        const archive = archiver('zip', { zlib: { level: 9 } })

        output.on('close', resolve)
        archive.on('warning', err => err.code === 'ENOENT' ? console.log(err) : reject(err))
        archive.on('error', reject)

        archive.pipe(output)
        archive.directory(releaseDir, projectName)
        archive.finalize()
      })
    } else {
      compress = Promise.resolve()
    }

    compress.then(() => {
      console.log(
        chalk.cyan(`Release your project source code at ${chalk.green(releasePath)}`)
      );

      console.log(
        `${chalk.cyan('Now you can uploading it to hyext open platform.')}`
      );
    }).catch(console.log)
  }).catch(err => { throw err });
}


main()
